Successfully connected to socket: 3
HTTP/1.1 200 OK
Date: Thu, 27 Oct 2016 01:07:41 GMT
Server: Apache/2.4.20 (Ubuntu)
X-Frame-Options: SAMEORIGIN
Last-Modified: Fri, 18 Sep 2015 17:02:57 GMT
ETag: "5e8f-5200880e1e6d0"
Accept-Ranges: bytes
Content-Length: 24207
Vary: Accept-Encoding
Connection: close
Content-Type: text/html

<html>
  <body>

    
<h1>The following text is taken from the Beej's Guide to Network Programmin
g</h1> <link href="beej.us/guide/bgnet/output/html/singlepage/bgnet.html">



    <h3 class="sect2title">5.2. <a name="socket"><b><tt class="titlefunc">socket()</tt></b>Get the File Descriptor!</a></h3>


    <p>I guess I can put it off no longer I have to talk about the
      <a name="indexId434909-92"></a><b><tt class="func">socket()</tt></b> system call.  Here's the
      breakdown:</p>

    <p
re class="code">#include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;

      int socket(int domain, int type, int protocol);
    </pre>


    <p>But what are these arguments?  They allow you to say what kind of
      socket you want (IPv4 or IPv6, stream or datagram, and TCP or UDP).</p>

    <p>It used to be people would hardcode these values, and you can
      absolutely still do that
lass="var">protocol</tt></i> can be set to <tt class="const">0</tt> to choose the
      proper protocol for the given <tt class="const">type</tt>.  Or y  is <tt class="const">SOCK_STREAM</tt> or <tt class="const">SOCK_DGRAM</tt>, and
      <i><tt c
ou can call
      <b><tt class="func">getprotobyname()</tt></b> to look up the protocol you want, "tcp" or
      "udp".)</p>

    <p>(This <tt class="const">PF_INET</tt> thing is a close relative of the <a name="indexId434909-93"></a><tt class="const">AF_INET</tt> that you can use when initializing
      the <i><tt class="var">sin_family</tt></i> field in your <nobr><tt class="type">struct sockadd
r_in</tt></nobr>.
      In fact, they're so closely related that they actually have the same
      value, and many programmers will call <b><tt class="func">socket()</tt></b> and pass
      <tt class="const">AF_INET</tt> as the first argument instead of
      <b><tt class="func">PF_INET</tt></b>.  Now, get some milk and cookies, because it's
      times for a story.  Once upon a time, a long time 
ago, it was thought
      that maybe an address family (what the "AF" in "<tt class="const">AF_INET</tt>"
      stands for) might support several protocols that were referred to by
      their protocol family (what the "PF" in "<tt class="const">PF_INET</tt>" stands
      for).  That didn't happen.  And they all lived happily ever after, The
      End.  So the most correct thing to do is to use <t
 and <tt class="const">PF_INET</tt> in
      your call to <b><tt class="func">socket()</tt></b>.)</p>

    <p>Anyway, enough of that.  What you really want to do is use the values
      from the results of the call to <b><tt class="func">getaddrinfo()</tt></b>, and feed
      them into <b><tt class="fun
c">socket()</tt></b> directly like this:</p>

    <pre class="code">int s;
      struct addrinfo hints, *res;

      // do the lookup
      // [pretend we already filled out the "hints" struct]
      getaddrinfo("www.example.com", "http", &amp;hints, &amp;res);

      // [again, you should do error-checking on getaddrinfo(), and walk
      // the "res" linked list looking for valid entries instead
 of just
      // assuming the first one is good (like many of these examples do.)
      // <a href="#clientserver">See the section on client/server</a> for real examples.]

      s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</pre>


    <p><b><tt class="func">socket()</tt></b> simply returns to you a <i>socket
	descriptor</i> that you can use in later system calls, or
 
     <tt class="const">-1</tt> on error.  The global variable <i><tt class="var">errno</tt></i> is set
      to the error's value (see the <a href="#errnoman"><i><tt class="var">errno</tt></i></a> man page for more details, and a
      quick note on using <i><tt class="var">errno</tt></i> in multithreaded programs.)</p>

    <p>Fine, fine, fine, but what good is this socket?  The answer is
      t
hat it's really no good by itself, and you need to read on and make
      more system calls for it to make any sense.</p>








    <h3 class="sect2title">5.3. <a name="bind"><b><tt class="titlefunc">bind()</tt></b>What port am I on?</a></h3>


    <p><a name="indexId434909-94"></a>Once you have a socket, you might have to associate
      that socket with a <a name="indexId434909-95"></a>port on
 your local machine.  (This
      is commonly done if you're going to <a name="indexId434909-96"></a><b><tt class="func">listen()</tt></b> for incoming connections on a
      specific port—multiplayer network games do this when they tell
      you to "connect to 192.168.5.10 port 3490".)  The port number is used by
      the kernel to match an incoming packet to a certain process's socket
      
descriptor.  If you're going to only be doing a <a name="indexId434909-97"></a><b><tt class="func">connect()</tt></b> (because you're the client, not
      the server), this is probably be unnecessary.  Read it anyway, just for
      kicks.</p>

    <p>Here is the synopsis for the <b><tt class="func">bind()</tt></b> system
      call:</p>

    <pre class="code">#include &lt;sys/types.h&gt;
      #
include &lt;sys/socket.h&gt;

      int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
    </pre>


    <p><i><tt class="var">sockfd</tt></i> is the socket file descriptor returned by
      <b><tt class="func">socket()</tt></b>.  <i><tt class="var">my_addr</tt></i> is a pointer to a
      <nobr><tt class="type">struct sockaddr</tt></nobr> that contains information about your
      addres
s, namely, port and <a name="indexId434909-98"></a>IP address.
      <i><tt class="var">addrlen</tt></i> is the length in bytes of that address.</p>

    <p>Whew.  That's a bit to absorb in one chunk.  Let's have an
      example that binds the socket to the host the program is running on,
      port 3490:</p>

    <pre class="code">struct addrinfo hints, *res;
      int sockfd;

      // first, l
oad up address structs with getaddrinfo():

      memset(&amp;hints, 0, sizeof hints);
      hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
      hints.ai_socktype = SOCK_STREAM;
      hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

      getaddrinfo(NULL, "3490", &amp;hints, &amp;res);

      // make a socket:

      sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, 
res-&gt;ai_protocol);

      // bind it to the port we passed in to getaddrinfo():

      bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


    <p>By using the <tt class="const">AI_PASSIVE</tt> flag, I'm telling the program
      to bind to the IP of the host it's running on.  If you want to bind to a
      specific local IP address, drop the <tt class="const">AI_PASSIVE</tt> and put an
 
t to <b><tt class="func">getaddrinfo()</tt></b>.</p>

    <p><b><tt class="func">bind()</tt></b> also returns <tt class="const">-1</tt>
      on error and sets <i><tt class="var">errno</tt></i> to the error's
      value.</p>

    <p>Lots of old code manually packs the <nobr><tt class="type">struct sockaddr_in</tt></nobr>
      before calling <b><tt class="f
unc">bind()</tt></b>.  Obviously this is IPv4-specific,
      but there's really nothing stopping you from doing the same thing with
      IPv6, except that using <b><tt class="func">getaddrinfo()</tt></b> is going to be
      easier, generally.  Anyway, the old code looks something like this:</p>

    <pre class="code">// !!! THIS IS THE OLD WAY !!!

      int sockfd;
      struct sockaddr_in my_
addr;

      sockfd = socket(PF_INET, SOCK_STREAM, 0);

      my_addr.sin_family = AF_INET;
      my_addr.sin_port = htons(MYPORT);     // short, network byte order
      my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
      memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);

      bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof my_addr);</pre>


    <p>In the above code, you could
 also assign <tt class="const">INADDR_ANY</tt> to
      the <i><tt class="var">s_addr</tt></i> field if you wanted to bind to your local IP
      address (like the <tt class="const">AI_PASSIVE</tt> flag, above.)  The IPv6
      version of <tt class="const">INADDR_ANY</tt> is a global variable
      <i><tt class="var">in6addr_any</tt></i> that is assigned into the <i><tt class="var">sin6_addr</tt><
/i>
      field of your <nobr><tt class="type">struct sockaddr_in6</tt></nobr>.  (There is also a macro
      <tt class="const">IN6ADDR_ANY_INIT</tt> that you can use in a variable
      initializer.)</p>

    <p>Another thing to watch out for when calling <b><tt class="func">bind()</tt></b>:
      don't go underboard with your port numbers.  <a name="indexId434909-99"></a>All ports
      below 10
24 are RESERVED (unless you're the superuser)!  You can have any
      port number above that, right up to 65535 (provided they aren't already
      being used by another program.)</p>

    <p>Sometimes, you might notice, you try to rerun a server and
      <b><tt class="func">bind()</tt></b> fails, claiming <a name="indexId434909-100"></a>"Address
      already in use." What does that mean?  Well
, a little bit of a socket
      that was connected is still hanging around in the kernel, and it's
      hogging the port.  You can either wait for it to clear (a minute or so),
      or add code to your program allowing it to reuse the port, like
      this:</p>

    <pre class="code"><a name="indexId434909-101"></a><a name="indexId434909-102"></a>int yes=1;
      //char yes='1'; // Solaris peop
le use this

      // lose the pesky "Address already in use" error message
      if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof(int)) == -1) {
      perror("setsockopt");
      exit(1);
      }
    </pre>


    <p><a name="indexId434909-103"></a>One small extra final note about
      <b><tt class="func">bind()</tt></b>: there are times when you won't absolutely have to
      call
 it.  If you are <a name="indexId434909-104"></a><b><tt class="func">connect()</tt></b>ing to a
      remote machine and you don't care what your local port is (as is the
      case with <b class="com">telnet</b> where you only care about the remote port),
      you can simply call <b><tt class="func">connect()</tt></b>, it'll check to see if the
      socket is unbound, and will <b><tt class="fun
c">bind()</tt></b> it to an unused local
      port if necessary.</p>








    <h3 class="sect2title">5.4. <a name="connect"><b><tt class="titlefunc">connect()</tt></b>Hey, you!</a></h3>


    <p><a name="indexId434909-105"></a>Let's just pretend for a few minutes that you're
      a telnet application.  Your user commands you (just like in the movie
      <a name="indexId434909-106"></a><i>TRO
N</i>) to get a socket file descriptor.  You
      comply and call <b><tt class="func">socket()</tt></b>.  Next, the user tells you to
      connect to "<tt class="tt">10.12.110.57</tt>" on port "<tt class="tt">23</tt>" (the standard
      telnet port.)  Yow!  What do you do now?</p>

    <p>Lucky for you, program, you're now perusing the section on
      <b><tt class="func">connect()</tt></b>—h
ow to connect to a remote host.  So read
      furiously onward!  No time to lose!</p>

    <p>The <b><tt class="func">connect()</tt></b> call is as follows:</p>

    <pre class="code">#include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;

      int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
    </pre>


    <p><i><tt class="var">sockfd</tt></i> is our friendly neighb
orhood socket
      file descriptor, as returned by the <b><tt class="func">socket()</tt></b> call,
      <i><tt class="var">serv_addr</tt></i> is a <nobr><tt class="type">struct sockaddr</tt></nobr>
      containing the destination port and IP address, and
      <i><tt class="var">addrlen</tt></i> is the length in bytes of the server address
      structure.</p>

    <p>All of this information ca
n be gleaned from the results of the
      <b><tt class="func">getaddrinfo()</tt></b> call, which rocks.</p>

    <p>Is this starting to make more sense?  I can't hear you from here, so
      I'll just have to hope that it is.  Let's have an example where we make
      a socket connection to "www.example.com", port 3490:</p>

    <pre class="code">struct addrinfo hints, *res;
      int sockfd;

  
, &amp;res);

      // make a socket:

      sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

      // connect!

      connect(sockfd, resSTREAM;

      getaddrinfo("www.example.com", "3490", &amp;hints
-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


    <p>Again, old-school programs filled out their own <nobr><tt class="type">struct
	  sockaddr_in</tt></nobr>s to pass to <b><tt class="func">connect()</tt></b>.  You can do that
      if you want to.  See the similar note in the <a href="#bind"><b><tt class="func">bind()</tt></b> section</a>, above.</p>

    <p>Be sure to check the return value from
  
    <b><tt class="func">connect()</tt></b>—it'll return <tt class="const">-1</tt> on error
      and set the variable <i><tt class="var">errno</tt></i>.</p>

    <p><a name="indexId434909-107"></a>Also, notice that we didn't call
      <b><tt class="func">bind()</tt></b>.  Basically, we don't care about our local port
      number; we only care where we're going (the remote port).  The kernel
  
    will choose a local port for us, and the site we connect to will
      automatically get this information from us.  No worries.</p>








    <h3 class="sect2title">5.5. <a name="listen"><b><tt class="titlefunc">listen()</tt></b>Will somebody please call
	me?</a></h3>


    <p><a name="indexId434909-108"></a>Ok, time for a change of pace.  What if you don't
      want to connect to a remote 
 and handle them in some way.  The process
      is two step: first you <b><tt class="func">listen()</tt></b>, then you
      <a name="indexId434909-109"></a><b><tt class="func">accept()</tt></b> (see below.)</p>

    <p>The listen call is fairly simple, but requires a bit of
      explanation:</p>

    <pre class="cod
e">int listen(int sockfd, int backlog);
    </pre>


    <p><i><tt class="var">sockfd</tt></i> is the usual socket file descriptor
      from the <b><tt class="func">socket()</tt></b> system call.
      <a name="indexId434909-110"></a><i><tt class="var">backlog</tt></i> is the number of
      connections allowed on the incoming queue.  What does that mean?  Well,
      incoming connections are goi
ng to wait in this queue until you
      <b><tt class="func">accept()</tt></b> them (see below) and this is the limit on how many
      can queue up.  Most systems silently limit this number to about 20; you
      can probably get away with setting it to <tt class="const">5</tt> or
      <tt class="const">10</tt>.</p>

    <p>Again, as per usual, <b><tt class="func">listen()</tt></b> returns
     
l your
      buddies which port to connect to!)  So if you're going to b
      error.</p>

    <p>Well, as you can probably imagine, we need to call
      <b><tt class="func">bind()</tt></b> before we call <b><tt class="func">listen()</tt></b> so that the
      server is running on a specific port.  (You have to be able to tel
e listening
      for incoming connections, the sequence of system calls you'll make
      is:</p>

    <pre class="code">getaddrinfo();
      socket();
      bind();
      listen();
      /* accept() goes here */
    </pre>


    <p>I'll just leave that in the place of sample code, since it's
      fairly self-explanatory.  (The code in the <b><tt class="func">accept()</tt></b>
      section, bel
ow, is more complete.)  The really tricky part of this whole
      sha-bang is the call to <b><tt class="func">accept()</tt></b>.</p>








    <h3 class="sect2title">5.6. <a name="accept"><b><tt class="titlefunc">accept()</tt></b>"Thank you for calling port
	3490."</a></h3>


    <p><a name="indexId434909-111"></a>Get ready—the <b><tt class="func">accept()</tt></b> call
      is kinda weird! 
 What's going to happen is this: someone far far away
      will try to <b><tt class="func">connect()</tt></b> to your machine on a port that you
      are <b><tt class="func">listen()</tt></b>ing on.  Their connection will be queued up
      waiting to be <b><tt class="func">accept()</tt></b>ed.  You call <b><tt class="func">accept()</tt></b>
      and you tell it to get the pending connection.  
> for the price of one!  The original one is still
      listening for more new connections, and the newly created one is finally
      ready to <b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b>.  W
e're there! </p>

    <p>The call is as follows:</p>

    <pre class="code">#include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;

      int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    </pre>


    <p><i><tt class="var">sockfd</tt></i> is the
      <b><tt class="func">listen()</tt></b>ing socket descriptor.  Easy enough.
      <i><tt class="var">addr</tt></i> will
 usually be a pointer to a local
      <nobr><tt class="type">struct sockaddr_storage</tt></nobr>.  This is where the information
      about the incoming connection will go (and with it you can determine
      which host is calling you from which port).  <i><tt class="var">addrlen</tt></i> is a
      local integer variable that should be set to <tt class="tt">sizeof(struct
	sockaddr_storage)</tt>
 before its address is passed to
      <b><tt class="func">accept()</tt></b>.  <b><tt class="func">accept()</tt></b> will not put more than
      that many bytes into <i><tt class="var">addr</tt></i>.  If it puts fewer in, it'll
      change the value of <i><tt class="var">addrlen</tt></i> to reflect that.</p>

    <p>Guess what?  <b><tt class="func">accept()</tt></b> returns <tt class="const">-1<
tt class="var">errno</tt></i> if an error occurs.  Betcha didn't figure that.</p>

    <p>Like before, this is a bunch to absorb in one chunk, so here's a
      sample code fragment for your perusal:</p>

    <pre class="code">#include &lt;string.h&gt;
      #include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;
      #include &lt;netinet/in.h&gt;

      #define M
YPORT "3490"  // the port users will be connecting to
      #define BACKLOG 10     // how many pending connections queue will hold

      int main(void)
      {
      struct sockaddr_storage their_addr;
      socklen_t addr_size;
      struct addrinfo hints, *res;
      int sockfd, new_fd;

      // !! don't forget your error checking for these calls !!

      // first, load up address structs wit
h getaddrinfo():

      memset(&amp;hints, 0, sizeof hints);
      hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
      hints.ai_socktype = SOCK_STREAM;
      hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

      getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

      // make a socket, bind it, and listen on it:

      sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype,
 res-&gt;ai_protocol);
      bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
      listen(sockfd, BACKLOG);

      // now accept an incoming connection:

      addr_size = sizeof their_addr;
      new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

      // ready to communicate on socket descriptor new_fd!
      .
      .
      .</pre>


    <p>Again, note that we will
 use the socket descriptor
      <i><tt class="var">new_fd</tt></i> for all <b><tt class="func">send()</tt></b> and
      <b><tt class="func">recv()</tt></b> calls.  If you're only getting one single connection
      ever, you can <b><tt class="func">close()</tt></b> the listening <i><tt class="var">sockfd</tt></i>
      in order to prevent more incoming connections on the same port, if you
      
so desire.</p>








    <h3 class="sect2title">5.7. <a name="sendrecv"><b><tt class="titlefunc">send()</tt></b> and <b><tt class="titlefunc">recv()</tt></b>Talk to me,
	baby!</a></h3>


    <p>These two functions are for communicating over stream sockets or
      connected datagram sockets.  If you want to use regular unconnected
      datagram sockets, you'll need to see the section on <a href
="#sendtorecv"><b><tt class="func">sendto()</tt></b> and
	<b><tt class="func">recvfrom()</tt></b></a>, below.</p>

    <p><a name="indexId434909-112"></a>The <b><tt class="func">send()</tt></b> call:</p>

    <pre class="code">int send(int sockfd, const void *msg, int len, int flags);
    </pre>


    <p><i><tt class="var">sockfd</tt></i> is the socket descriptor you want to
      send data to (wh
unc">accept()</tt></b>.) <i><tt class="var">msg</tt></i> is a pointer
      to the data you want to send, and <i><tt class="var">len</tt></i> is the
      length of that data in bytes.  Just set <i><tt class="var">flags</tt></i> to
      <tt class="const">0</tt>.  (See the <b><tt
 class="func">send()</tt></b> man page
      for more information concerning flags.)</p>

    <p>Some sample code might be:</p>

    <pre class="code">char *msg = "Beej was here!";
      int len, bytes_sent;
      .
      .
      .
      len = strlen(msg);
      bytes_sent = send(sockfd, msg, len, 0);
      .
      .
      .
    </pre>


    <p><b><tt class="func">send()</tt></b> returns the numbe
r of bytes actually
      sent out—<i>this might be less than the number you told it to
	send!</i>  See, sometimes you tell it to send a whole gob of data and
      it just can't handle it.  It'll fire off as much of the data as it can,
      and trust you to send the rest later.  Remember, if the value returned
      by <b><tt class="func">send()</tt></b> doesn't match the value in <i><tt class
p><a name="indexId434909-113"></up to you to send the rest of the string.  The good news is this:
      if the packet is small (less than 1K or so) it will <i>probably</i>
      manage to send the whole thing all in one go.  Again, <tt class="const">-1</tt>
      is returned on error, and <i><tt class="var">errno</tt></i> is set to the error
      number.</p>

    <
a>The <b><tt class="func">recv()</tt></b> call is similar in many
      respects:</p>

    <pre class="code">int recv(int sockfd, void *buf, int len, int flags);</pre>


    <p><i><tt class="var">sockfd</tt></i> is the socket descriptor to read
      from, <i><tt class="var">buf</tt></i> is the buffer to read the information
      into, <i><tt class="var">len</tt></i> is the maximum length of the 
buffer,
      and <i><tt class="var">flags</tt></i> can again be set to
      <tt class="const">0</tt>.  (See the <b><tt class="func">recv()</tt></b> man page
      for flag information.)</p>

    <p><b><tt class="func">recv()</tt></b> returns the number of bytes actually
      read into the buffer, or <tt class="const">-1</tt> on error (with
      <i><tt class="var">errno</tt></i> set, accordingl
y.)</p>

    <p>Wait!  <b><tt class="func">recv()</tt></b> can return
      <tt class="const">0</tt>.  This can mean only one thing: the remote side
      has closed the connection on you!  A return value of
      <tt class="const">0</tt> is <b><tt class="func">recv()</tt></b>'s way of letting
      you know this has occurred.</p>

    <p>There, that was easy, wasn't it?  You can now pass data bac
k and
      forth on stream sockets!  Whee!  You're a Unix Network
      Programmer!</p> 

  </body>
</html>


COUNT IS : 72
